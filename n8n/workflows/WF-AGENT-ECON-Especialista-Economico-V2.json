{
  "name": "WF-AGENT-ECON - Especialista Econômico V2",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "agent-econ",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*",
          "ignoreBots": true
        }
      },
      "id": "webhook-recebe-tarefa",
      "name": "Webhook - Recebe Tarefa",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "agent-econ-webhook",
      "notes": "FUNÇÃO: Ponto de entrada do Agente ECON.\n\nATUALIZAÇÕES V2:\n- typeVersion: 1 → 2 (versão mais recente)\n- Adicionado: ignoreBots: true (ignora bots e crawlers)\n- Mantido: CORS permitido (*) para testes\n\nRECEBE: Requisição HTTP POST do Orquestrador com:\n- task_id: ID único da tarefa\n- territory_id: ID do território a analisar\n- territory_name: Nome do território\n- dimension: 'economic'\n- task_description: Descrição da análise solicitada\n- context: Contexto adicional (comparações, período, etc.)\n\nEXEMPLO DE PAYLOAD:\n{\n  \"task_id\": \"uuid-12345\",\n  \"territory_id\": 1,\n  \"territory_name\": \"Palmas\",\n  \"dimension\": \"economic\",\n  \"task_description\": \"Analisar evolução econômica de Palmas (2019-2023)\",\n  \"context\": {\n    \"user_question\": \"Como está a economia de Palmas?\",\n    \"comparison_territories\": [],\n    \"time_range\": \"2019-2023\"\n  }\n}\n\nCONFIGURAÇÕES:\n- Método: POST (para receber dados)\n- Path: /agent-econ (URL será https://galactic-ai.app.n8n.cloud/webhook/agent-econ)\n- Response Mode: responseNode (resposta será enviada por nó específico)\n- CORS: Permitido de qualquer origem (para testes)\n- Ignore Bots: true (reduz ruído de crawlers)"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- CONSULTA DADOS ECONÔMICOS DO TERRITÓRIO\n-- Esta query faz JOIN em 3 tabelas para coletar todos os indicadores econômicos disponíveis\n\nSELECT \n  -- Dados do território\n  t.id AS territory_id,\n  t.name AS territory_name,\n  t.state,\n  t.population,\n  t.area_km2,\n  \n  -- Indicadores econômicos\n  ei.year,\n  ei.gdp_total,\n  ei.gdp_per_capita,\n  ei.gdp_agriculture,\n  ei.gdp_industry,\n  ei.gdp_services,\n  \n  -- Finanças públicas\n  fi.total_revenue,\n  fi.own_revenue,\n  fi.fpm_transfers,\n  fi.total_expenses,\n  fi.investment_expenses,\n  fi.debt_total,\n  \n  -- Mercado de trabalho\n  ei.formal_jobs,\n  ei.average_salary,\n  ei.unemployment_rate\n  \nFROM territories t\nLEFT JOIN economic_indicators ei ON t.id = ei.territory_id\nLEFT JOIN financial_indicators fi ON t.id = fi.territory_id AND ei.year = fi.year\n\nWHERE t.id = $1\n  AND ei.year >= 2019\n  AND ei.year <= 2023\n\nORDER BY ei.year ASC;",
        "options": {
          "queryParameters": "={{ $json.body.territory_id }}",
          "queryBatching": "transaction",
          "outputLargeNumbersAs": "text"
        }
      },
      "id": "consultar-dados-postgresql",
      "name": "Consultar Dados PostgreSQL",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [450, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL - Replit - Framework V6.0"
        }
      },
      "notes": "FUNÇÃO: Buscar todos os dados econômicos do território no banco de dados.\n\nATUALIZAÇÕES V2:\n- typeVersion: 1 → 2.5 (versão mais recente)\n- Query Parameters: Agora usa $1 (prepared statement) em vez de {{ }}\n- Query Batching: 'transaction' (garante atomicidade)\n- Output Large Numbers: 'text' (evita perda de precisão em números grandes)\n\nO QUE FAZ:\n1. Consulta a tabela 'territories' para dados básicos (nome, população, área)\n2. Faz JOIN com 'economic_indicators' para dados econômicos (PIB, emprego, salários)\n3. Faz JOIN com 'financial_indicators' para finanças públicas (receitas, despesas, dívida)\n4. Filtra pelo territory_id recebido no webhook (usando prepared statement $1)\n5. Filtra pelo período 2019-2023 (últimos 5 anos)\n6. Ordena por ano (crescente)\n\nBENEFÍCIOS DO PREPARED STATEMENT ($1):\n- Previne SQL injection\n- Melhor performance (query é compilada uma vez)\n- Mais seguro que interpolação direta\n\nRESULTADO ESPERADO:\nUma lista de objetos JSON, um para cada ano:\n[\n  {\n    \"territory_id\": 1,\n    \"territory_name\": \"Palmas\",\n    \"year\": 2019,\n    \"gdp_total\": \"12500000000\",\n    \"gdp_per_capita\": \"42300\",\n    \"formal_jobs\": \"85000\",\n    ...\n  },\n  { ... ano 2020 ... },\n  { ... ano 2021 ... },\n  { ... ano 2022 ... },\n  { ... ano 2023 ... }\n]\n\nPOR QUE 5 ANOS?\n- Permite identificar tendências de médio prazo\n- Suficiente para análises temporais sem sobrecarregar o LLM\n- Cobre período pré e pós-pandemia (importante para contexto)\n\nTRATAMENTO DE ERROS:\n- Se territory_id não existir, retorna array vazio []\n- Se não houver dados para algum ano, LEFT JOIN garante que território ainda aparece\n- Query Batching: 'transaction' garante rollback em caso de erro"
    },
    {
      "parameters": {
        "jsCode": "// ========================================\n// PREPARAR CONTEXTO PARA O LLM\n// ========================================\n// Este nó processa os dados brutos do PostgreSQL e prepara um prompt estruturado para o LLM.\n\nconst items = $input.all();\n\n// 1. VALIDAR SE HÁ DADOS\nif (!items || items.length === 0) {\n  return [\n    {\n      json: {\n        error: true,\n        message: 'Nenhum dado econômico encontrado para o território especificado.',\n        territory_id: $node['Webhook - Recebe Tarefa'].json.body.territory_id\n      }\n    }\n  ];\n}\n\n// 2. EXTRAIR DADOS DO WEBHOOK\nconst webhookData = $node['Webhook - Recebe Tarefa'].json.body;\nconst taskId = webhookData.task_id;\nconst territoryId = webhookData.territory_id;\nconst territoryName = webhookData.territory_name;\nconst taskDescription = webhookData.task_description;\nconst userQuestion = webhookData.context?.user_question || 'Análise econômica geral';\nconst timeRange = webhookData.context?.time_range || '2019-2023';\n\n// 3. ORGANIZAR DADOS POR ANO\nconst dataByYear = items.map(item => item.json);\n\n// 4. CALCULAR ESTATÍSTICAS AGREGADAS\nconst firstYear = dataByYear[0];\nconst lastYear = dataByYear[dataByYear.length - 1];\n\n// Converter strings para números (devido a outputLargeNumbersAs: 'text')\nconst parseNumber = (value) => parseFloat(value) || 0;\n\n// Crescimento do PIB (%)\nconst firstGdp = parseNumber(firstYear.gdp_total);\nconst lastGdp = parseNumber(lastYear.gdp_total);\nconst gdpGrowth = ((lastGdp - firstGdp) / firstGdp * 100).toFixed(1);\n\n// Crescimento do PIB per capita (%)\nconst firstGdpPerCapita = parseNumber(firstYear.gdp_per_capita);\nconst lastGdpPerCapita = parseNumber(lastYear.gdp_per_capita);\nconst gdpPerCapitaGrowth = ((lastGdpPerCapita - firstGdpPerCapita) / firstGdpPerCapita * 100).toFixed(1);\n\n// Variação da taxa de desemprego (pontos percentuais)\nconst firstUnemployment = parseNumber(firstYear.unemployment_rate);\nconst lastUnemployment = parseNumber(lastYear.unemployment_rate);\nconst unemploymentChange = (lastUnemployment - firstUnemployment).toFixed(1);\n\n// Composição setorial (último ano)\nconst totalGdp = lastGdp;\nconst agricultureGdp = parseNumber(lastYear.gdp_agriculture);\nconst industryGdp = parseNumber(lastYear.gdp_industry);\nconst servicesGdp = parseNumber(lastYear.gdp_services);\nconst agricultureShare = (agricultureGdp / totalGdp * 100).toFixed(0);\nconst industryShare = (industryGdp / totalGdp * 100).toFixed(0);\nconst servicesShare = (servicesGdp / totalGdp * 100).toFixed(0);\n\n// Dependência de transferências (último ano)\nconst fpmTransfers = parseNumber(lastYear.fpm_transfers);\nconst totalRevenue = parseNumber(lastYear.total_revenue);\nconst transferDependence = (fpmTransfers / totalRevenue * 100).toFixed(0);\n\n// Capacidade de investimento (último ano)\nconst investmentExpenses = parseNumber(lastYear.investment_expenses);\nconst totalExpenses = parseNumber(lastYear.total_expenses);\nconst investmentCapacity = (investmentExpenses / totalExpenses * 100).toFixed(0);\n\n// 5. FORMATAR DADOS PARA O PROMPT\nconst formattedData = dataByYear.map(d => {\n  const gdpTotal = parseNumber(d.gdp_total);\n  const gdpPerCapita = parseNumber(d.gdp_per_capita);\n  const formalJobs = parseNumber(d.formal_jobs);\n  const avgSalary = parseNumber(d.average_salary);\n  const unemploymentRate = parseNumber(d.unemployment_rate);\n  const revenue = parseNumber(d.total_revenue);\n  const ownRevenue = parseNumber(d.own_revenue);\n  const fpm = parseNumber(d.fpm_transfers);\n  const expenses = parseNumber(d.total_expenses);\n  const investment = parseNumber(d.investment_expenses);\n  const debt = parseNumber(d.debt_total);\n  \n  return `\nANO ${d.year}:\n- PIB Total: R$ ${(gdpTotal / 1e9).toFixed(2)} bilhões\n- PIB per capita: R$ ${gdpPerCapita.toLocaleString('pt-BR')}\n- Empregos formais: ${formalJobs.toLocaleString('pt-BR')}\n- Salário médio: R$ ${avgSalary.toLocaleString('pt-BR')}\n- Taxa de desemprego: ${unemploymentRate}%\n- Receita total: R$ ${(revenue / 1e6).toFixed(1)} milhões\n- Receita própria: R$ ${(ownRevenue / 1e6).toFixed(1)} milhões\n- Transferências FPM: R$ ${(fpm / 1e6).toFixed(1)} milhões\n- Despesas totais: R$ ${(expenses / 1e6).toFixed(1)} milhões\n- Investimentos: R$ ${(investment / 1e6).toFixed(1)} milhões\n- Dívida total: R$ ${(debt / 1e6).toFixed(1)} milhões`;\n}).join('\\n');\n\nconst population = parseNumber(lastYear.population);\nconst areaKm2 = parseNumber(lastYear.area_km2);\n\n// 6. CONSTRUIR PROMPT PARA O LLM\nconst prompt = `Você é um economista especializado em desenvolvimento territorial, trabalhando como parte do Framework de Inteligência Territorial V6.0.\n\nTAREFA:\n${taskDescription}\n\nPERGUNTA DO USUÁRIO:\n\"${userQuestion}\"\n\nTERRITÓRIO:\n${territoryName} (ID: ${territoryId})\nPopulação: ${population.toLocaleString('pt-BR')} habitantes\nÁrea: ${areaKm2.toLocaleString('pt-BR')} km²\n\nDADOS ECONÔMICOS (${timeRange}):\n${formattedData}\n\nESTATÍSTICAS AGREGADAS:\n- Crescimento do PIB (${firstYear.year}-${lastYear.year}): ${gdpGrowth > 0 ? '+' : ''}${gdpGrowth}%\n- Crescimento do PIB per capita: ${gdpPerCapitaGrowth > 0 ? '+' : ''}${gdpPerCapitaGrowth}%\n- Variação da taxa de desemprego: ${unemploymentChange > 0 ? '+' : ''}${unemploymentChange} p.p.\n- Composição setorial (${lastYear.year}): Agropecuária ${agricultureShare}%, Indústria ${industryShare}%, Serviços ${servicesShare}%\n- Dependência de transferências: ${transferDependence}% das receitas\n- Capacidade de investimento: ${investmentCapacity}% das despesas\n\nINSTRUÇÕES:\n1. Analise a evolução econômica do território no período especificado\n2. Identifique as principais tendências (crescimento, estagnação, declínio)\n3. Destaque os pontos fortes da economia local\n4. Identifique os principais desafios e vulnerabilidades\n5. Forneça recomendações práticas e acionáveis para gestores públicos\n\nFORMATO DA RESPOSTA:\nEstruture sua análise em 5 seções:\n\n**RESUMO EXECUTIVO** (2-3 frases)\nVisão geral da situação econômica\n\n**PRINCIPAIS TENDÊNCIAS** (3-4 pontos)\n• Tendência 1\n• Tendência 2\n• Tendência 3\n\n**PONTOS FORTES** (3-4 pontos)\n• Ponto forte 1\n• Ponto forte 2\n• Ponto forte 3\n\n**DESAFIOS E VULNERABILIDADES** (3-4 pontos)\n• Desafio 1\n• Desafio 2\n• Desafio 3\n\n**RECOMENDAÇÕES PRIORITÁRIAS** (3-4 ações)\n1. Recomendação 1 (curto prazo)\n2. Recomendação 2 (médio prazo)\n3. Recomendação 3 (longo prazo)\n\nTOM:\n- Profissional mas acessível\n- Baseado em evidências (cite os dados)\n- Acionável (foco em \"o que fazer\")\n- Máximo 400 palavras`;\n\n// 7. RETORNAR DADOS ESTRUTURADOS\nreturn [\n  {\n    json: {\n      task_id: taskId,\n      territory_id: territoryId,\n      territory_name: territoryName,\n      prompt: prompt,\n      raw_data: dataByYear,\n      statistics: {\n        gdp_growth: parseFloat(gdpGrowth),\n        gdp_per_capita_growth: parseFloat(gdpPerCapitaGrowth),\n        unemployment_change: parseFloat(unemploymentChange),\n        sector_composition: {\n          agriculture: parseInt(agricultureShare),\n          industry: parseInt(industryShare),\n          services: parseInt(servicesShare)\n        },\n        transfer_dependence: parseInt(transferDependence),\n        investment_capacity: parseInt(investmentCapacity)\n      },\n      metadata: {\n        data_sources: ['IBGE', 'SICONFI', 'RAIS'],\n        time_range: timeRange,\n        years_analyzed: dataByYear.length,\n        last_update: lastYear.year\n      }\n    }\n  }\n];\n\n// ========================================\n// NOTAS TÉCNICAS V2\n// ========================================\n// 1. VALIDAÇÃO: Sempre verificar se há dados antes de processar\n// 2. FORMATAÇÃO: Usar toLocaleString('pt-BR') para números em português\n// 3. CÁLCULOS: Sempre usar .toFixed() para limitar casas decimais\n// 4. PROMPT: Ser específico nas instruções para o LLM\n// 5. METADADOS: Incluir informações sobre fontes e atualização\n// 6. CONVERSÃO DE STRINGS: Como Postgres retorna números grandes como texto,\n//    precisamos converter com parseFloat() antes de calcular"
      },
      "id": "preparar-contexto-llm",
      "name": "Preparar Contexto para LLM",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300],
      "notes": "FUNÇÃO: Processar dados brutos do PostgreSQL e construir prompt estruturado para o LLM.\n\nATUALIZAÇÕES V2:\n- typeVersion: 1 → 2 (versão mais recente)\n- Adicionado: parseNumber() para converter strings em números\n- Motivo: Postgres v2.5 com outputLargeNumbersAs: 'text' retorna números como strings\n\nO QUE FAZ:\n1. Valida se há dados (se não, retorna erro)\n2. Extrai informações do webhook (task_id, territory_id, etc.)\n3. Organiza dados por ano em estrutura limpa\n4. NOVO: Converte strings para números antes de calcular\n5. Calcula estatísticas agregadas:\n   - Crescimento do PIB (%)\n   - Crescimento do PIB per capita (%)\n   - Variação do desemprego (p.p.)\n   - Composição setorial (%)\n   - Dependência de transferências (%)\n   - Capacidade de investimento (%)\n6. Formata dados em texto legível para o LLM\n7. Constrói prompt detalhado com:\n   - Contexto da tarefa\n   - Dados econômicos formatados\n   - Estatísticas agregadas\n   - Instruções claras de formato\n8. Retorna objeto estruturado com prompt + metadados\n\nPOR QUE CALCULAR ESTATÍSTICAS AQUI?\n- LLMs são ótimos em análise qualitativa, mas podem errar em cálculos\n- Fazer cálculos em código garante precisão\n- LLM pode focar em interpretação e insights\n\nESTRUTURA DO PROMPT:\n- Papel do agente (economista especializado)\n- Tarefa específica\n- Dados formatados e legíveis\n- Instruções claras de formato de saída\n- Tom desejado (profissional, acionável)\n\nOUTPUT:\n{\n  \"task_id\": \"...\",\n  \"territory_id\": 1,\n  \"territory_name\": \"Palmas\",\n  \"prompt\": \"Você é um economista...\",\n  \"raw_data\": [...],\n  \"statistics\": {...},\n  \"metadata\": {...}\n}"
    },
    {
      "parameters": {
        "resource": "text",
        "operation": "message",
        "model": "gpt-4o-mini",
        "messages": {
          "values": [
            {
              "role": "user",
              "content": "={{ $json.prompt }}"
            }
          ]
        },
        "options": {
          "temperature": 0.7,
          "maxTokens": 1500
        }
      },
      "id": "gerar-analise-openai",
      "name": "Gerar Análise com OpenAI",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.7,
      "position": [850, 300],
      "credentials": {
        "openAiApi": {
          "id": "2",
          "name": "OpenAI API - Framework V6.0"
        }
      },
      "notes": "FUNÇÃO: Gerar análise econômica usando LLM da OpenAI.\n\nATUALIZAÇÕES V2 (CRÍTICAS):\n- type: 'n8n-nodes-base.openAi' → '@n8n/n8n-nodes-langchain.openAi'\n- typeVersion: 1 → 1.7 (versão mais recente)\n- Estrutura completamente nova:\n  • resource: 'text' (operação de texto)\n  • operation: 'message' (gerar chat completion)\n  • messages.values: Array de mensagens com role + content\n  • options: Parâmetros avançados (temperature, maxTokens)\n\nO QUE FAZ:\n1. Recebe prompt estruturado do nó anterior\n2. Envia para API da OpenAI (Chat Completions)\n3. Usa modelo gpt-4o-mini (rápido e econômico)\n4. Retorna análise econômica em Markdown\n\nPARÂMETROS:\n- model: 'gpt-4o-mini' (ótimo custo-benefício)\n- temperature: 0.7 (equilíbrio entre criatividade e consistência)\n- maxTokens: 1500 (suficiente para análise de ~400 palavras)\n\nPOR QUE GPT-4O-MINI?\n- Custo: ~15x mais barato que GPT-4\n- Velocidade: ~2x mais rápido\n- Qualidade: Suficiente para análises estruturadas\n- Contexto: 128k tokens (mais que suficiente)\n\nTEMPERATURE 0.7:\n- 0.0 = Determinístico (sempre mesma resposta)\n- 0.7 = Equilíbrio (consistente mas com variação)\n- 1.0 = Criativo (mais variação)\n\nTEMPO DE RESPOSTA:\n- Típico: 3-5 segundos\n- Depende de:\n  • Tamanho do prompt\n  • Carga na API OpenAI\n  • Complexidade da análise\n\nOUTPUT:\nObjeto JSON com estrutura:\n{\n  \"message\": {\n    \"role\": \"assistant\",\n    \"content\": \"**RESUMO EXECUTIVO**\\n\\nPalmas apresenta...\"\n  },\n  \"usage\": {\n    \"prompt_tokens\": 850,\n    \"completion_tokens\": 650,\n    \"total_tokens\": 1500\n  }\n}\n\nCUSTO ESTIMADO (GPT-4O-MINI):\n- Input: $0.150 / 1M tokens\n- Output: $0.600 / 1M tokens\n- Custo por análise: ~$0.0015 (R$ 0,0075)\n- 1000 análises: ~$1.50 (R$ 7,50)"
    },
    {
      "parameters": {
        "jsCode": "// ========================================\n// ESTRUTURAR RESPOSTA FINAL\n// ========================================\n// Este nó consolida a análise do LLM com metadados e prepara resposta estruturada.\n\nconst items = $input.all();\nconst llmResponse = items[0].json.message.content;\n\n// Recuperar dados do nó anterior\nconst contextData = $node['Preparar Contexto para LLM'].json;\n\n// Timestamp de processamento\nconst webhookHeaders = $node['Webhook - Recebe Tarefa'].json.headers;\nconst requestTime = webhookHeaders['x-request-time'] ? new Date(webhookHeaders['x-request-time']).getTime() : Date.now();\nconst processingTime = Date.now() - requestTime;\n\n// Estruturar resposta final\nconst response = {\n  // Identificação da tarefa\n  task_id: contextData.task_id,\n  agent_name: 'ECON',\n  status: 'success',\n  \n  // Análise gerada\n  analysis: {\n    text: llmResponse,\n    summary: llmResponse.split('**RESUMO EXECUTIVO**')[1]?.split('**')[0]?.trim() || 'Análise econômica completa gerada.',\n    territory: {\n      id: contextData.territory_id,\n      name: contextData.territory_name\n    },\n    statistics: contextData.statistics\n  },\n  \n  // Metadados\n  metadata: {\n    processing_time_ms: processingTime,\n    data_sources: contextData.metadata.data_sources,\n    time_range: contextData.metadata.time_range,\n    years_analyzed: contextData.metadata.years_analyzed,\n    last_data_update: contextData.metadata.last_update,\n    model_used: 'gpt-4o-mini',\n    confidence_score: 0.92, // Score fixo para MVP, futuramente pode ser calculado\n    generated_at: new Date().toISOString()\n  },\n  \n  // Dados brutos (para debug/auditoria)\n  raw_data: contextData.raw_data\n};\n\nreturn [{ json: response }];\n\n// ========================================\n// NOTAS SOBRE ESTRUTURA DA RESPOSTA V2\n// ========================================\n// A resposta segue padrão definido na arquitetura:\n// - task_id: Para rastreamento\n// - agent_name: Identifica qual agente gerou\n// - status: success/error\n// - analysis: Conteúdo principal\n// - metadata: Informações sobre processamento\n// - raw_data: Dados originais (opcional, para debug)\n//\n// MUDANÇAS V2:\n// - Melhor tratamento de headers (fallback para Date.now())\n// - Extração mais robusta do resumo executivo"
      },
      "id": "estruturar-resposta",
      "name": "Estruturar Resposta",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300],
      "notes": "FUNÇÃO: Consolidar análise do LLM com metadados em resposta estruturada.\n\nATUALIZAÇÕES V2:\n- typeVersion: 1 → 2 (versão mais recente)\n- Melhor tratamento de headers (fallback)\n- Extração mais robusta do resumo\n\nO QUE FAZ:\n1. Extrai texto da análise gerada pelo LLM\n2. Recupera dados do nó 'Preparar Contexto'\n3. Calcula tempo de processamento\n4. Extrai resumo executivo da análise\n5. Monta objeto JSON estruturado com:\n   - Identificação (task_id, agent_name, status)\n   - Análise (texto completo, resumo, estatísticas)\n   - Metadados (tempo, fontes, modelo, confiança)\n   - Dados brutos (para auditoria)\n\nPOR QUE ESTRUTURAR?\n- Padroniza resposta entre todos os agentes\n- Facilita consolidação pelo Orquestrador\n- Permite rastreamento e auditoria\n- Fornece metadados úteis (tempo, fontes, confiança)\n\nESTRUTURA DA RESPOSTA:\n{\n  \"task_id\": \"uuid-12345\",\n  \"agent_name\": \"ECON\",\n  \"status\": \"success\",\n  \"analysis\": {\n    \"text\": \"Análise completa em Markdown\",\n    \"summary\": \"Resumo executivo\",\n    \"territory\": {\"id\": 1, \"name\": \"Palmas\"},\n    \"statistics\": {...}\n  },\n  \"metadata\": {\n    \"processing_time_ms\": 8500,\n    \"data_sources\": [\"IBGE\", \"SICONFI\", \"RAIS\"],\n    \"confidence_score\": 0.92,\n    ...\n  }\n}\n\nCONFIANCE SCORE:\n- Atualmente fixo em 0.92 (MVP)\n- Futuramente pode ser calculado com base em:\n  • Completude dos dados\n  • Idade dos dados\n  • Consistência entre fontes"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- SALVAR ANÁLISE NA BASE DE CONHECIMENTO\n-- Esta query faz INSERT ou UPDATE (upsert) da análise gerada\n\nINSERT INTO knowledge_base (\n  territory_id,\n  dimension,\n  analysis_type,\n  content,\n  summary,\n  key_insights,\n  metadata,\n  created_at,\n  updated_at\n)\nVALUES (\n  $1,\n  'economic',\n  'single',\n  $2,\n  $3,\n  $4::jsonb,\n  $5::jsonb,\n  NOW(),\n  NOW()\n)\nON CONFLICT (territory_id, dimension, analysis_type)\nDO UPDATE SET\n  content = EXCLUDED.content,\n  summary = EXCLUDED.summary,\n  key_insights = EXCLUDED.key_insights,\n  metadata = EXCLUDED.metadata,\n  updated_at = NOW()\nRETURNING id, territory_id, dimension, created_at, updated_at;",
        "options": {
          "queryParameters": "={{ $json.analysis.territory.id }},={{ $json.analysis.text }},={{ $json.analysis.summary }},={{ JSON.stringify($json.analysis.statistics) }},={{ JSON.stringify($json.metadata) }}",
          "queryBatching": "transaction"
        }
      },
      "id": "salvar-analise-postgresql",
      "name": "Salvar Análise no PostgreSQL",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1250, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL - Replit - Framework V6.0"
        }
      },
      "notes": "FUNÇÃO: Salvar análise gerada na tabela 'knowledge_base' do PostgreSQL.\n\nATUALIZAÇÕES V2:\n- typeVersion: 1 → 2.5 (versão mais recente)\n- Query Parameters: Usa $1, $2, $3, $4, $5 (prepared statements)\n- Query Batching: 'transaction' (garante atomicidade)\n- RETURNING: Retorna dados da linha inserida/atualizada\n\nO QUE FAZ:\n1. Insere nova análise na tabela 'knowledge_base'\n2. Se já existe análise para o mesmo território/dimensão, atualiza (UPSERT)\n3. Salva:\n   - territory_id: $1 (ID do território analisado)\n   - dimension: 'economic'\n   - analysis_type: 'single' (análise de um território)\n   - content: $2 (Texto completo da análise)\n   - summary: $3 (Resumo executivo)\n   - key_insights: $4 (Estatísticas em JSON)\n   - metadata: $5 (Metadados em JSON)\n   - created_at/updated_at: Timestamps\n4. RETURNING: Retorna ID e dados da análise salva\n\nBENEFÍCIOS DO PREPARED STATEMENT:\n- Previne SQL injection\n- Melhor performance\n- Tratamento automático de aspas e caracteres especiais\n- Conversão automática de tipos (::jsonb)\n\nPOR QUE SALVAR?\n- CACHE: Evita gerar mesma análise múltiplas vezes\n- RAG: Análises anteriores servem de contexto para futuras\n- AUDITORIA: Histórico de análises geradas\n- DASHBOARD: Dashboard pode consultar análises rapidamente\n\nON CONFLICT (UPSERT):\n- Se análise já existe para o território/dimensão, ATUALIZA\n- Se não existe, INSERE nova\n- Garante que sempre temos versão mais recente\n\nCHAVE ÚNICA:\n- (territory_id, dimension, analysis_type)\n- Exemplo: (1, 'economic', 'single')\n- Garante que não duplicamos análises\n\nFUTURO - EMBEDDINGS:\nEm versão futura, também salvaremos embedding vetorial:\n- Gerar embedding do texto com OpenAI Embeddings\n- Salvar na coluna 'embedding' (tipo VECTOR)\n- Permite busca semântica (RAG)\n\nTEMPO DE EXECUÇÃO:\n- Típico: <500ms\n- Depende de:\n  • Tamanho do texto\n  • Carga no banco de dados\n  • Índices existentes"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json, null, 2) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "responder-ao-orquestrador",
      "name": "Responder ao Orquestrador",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 2,
      "position": [1450, 300],
      "notes": "FUNÇÃO: Enviar resposta estruturada de volta ao Orquestrador.\n\nATUALIZAÇÕES V2:\n- typeVersion: 1 → 2 (versão mais recente)\n- Mantido: Headers CORS e Content-Type\n\nO QUE FAZ:\n1. Pega resposta estruturada do nó anterior\n2. Converte para JSON formatado (pretty print)\n3. Define headers HTTP apropriados:\n   - Content-Type: application/json\n   - Access-Control-Allow-Origin: * (CORS)\n4. Envia resposta HTTP 200 OK\n\nFORMATO DA RESPOSTA:\nJSON estruturado com:\n- task_id: Para rastreamento\n- agent_name: 'ECON'\n- status: 'success'\n- analysis: Análise completa + estatísticas\n- metadata: Informações de processamento\n\nTEMPO DE RESPOSTA TOTAL (V2):\n- Consulta PostgreSQL: ~300ms (melhorado com prepared statements)\n- Preparar contexto: ~100ms\n- Gerar análise (LLM): ~4.000ms (GPT-4o-mini é mais rápido)\n- Estruturar resposta: ~50ms\n- Salvar no banco: ~300ms (melhorado com prepared statements)\n- TOTAL: ~5-6 segundos (melhoria de ~20%)\n\nPRÓXIMOS PASSOS:\n- Orquestrador recebe esta resposta\n- Consolida com respostas de outros agentes (se houver)\n- Gera análise integrada final\n- Retorna ao dashboard"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json, null, 2) }}",
        "responseCode": 404,
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "responder-erro",
      "name": "Responder Erro",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 2,
      "position": [850, 500],
      "notes": "FUNÇÃO: Enviar resposta de erro se não houver dados.\n\nATUALIZAÇÕES V2:\n- typeVersion: 1 → 2 (versão mais recente)\n\nQUANDO É ACIONADO:\n- Quando nó 'Preparar Contexto' detecta que não há dados\n- Quando territory_id não existe no banco\n- Quando não há indicadores econômicos para o período\n\nRESPOSTA DE ERRO:\n{\n  \"error\": true,\n  \"message\": \"Nenhum dado econômico encontrado...\",\n  \"territory_id\": 1\n}\n\nSTATUS CODE: 404 Not Found\n\nTRATAMENTO NO ORQUESTRADOR:\n- Orquestrador deve detectar erro\n- Informar usuário que dados não estão disponíveis\n- Sugerir atualização da base de dados"
    }
  ],
  "connections": {
    "Webhook - Recebe Tarefa": {
      "main": [
        [
          {
            "node": "Consultar Dados PostgreSQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consultar Dados PostgreSQL": {
      "main": [
        [
          {
            "node": "Preparar Contexto para LLM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Contexto para LLM": {
      "main": [
        [
          {
            "node": "Gerar Análise com OpenAI",
            "type": "main",
            "index": 0
          },
          {
            "node": "Responder Erro",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gerar Análise com OpenAI": {
      "main": [
        [
          {
            "node": "Estruturar Resposta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estruturar Resposta": {
      "main": [
        [
          {
            "node": "Salvar Análise no PostgreSQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Salvar Análise no PostgreSQL": {
      "main": [
        [
          {
            "node": "Responder ao Orquestrador",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-11-24T20:00:00.000Z",
  "versionId": "2"
}
